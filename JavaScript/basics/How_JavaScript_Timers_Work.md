# 자바스크립트 타이머는 어떻게 작동할까?

원문 : [How JavaScript Timers Work](https://johnresig.com/blog/how-javascript-timers-work/) (John Resig) 

기본적인 수준에서 자바스크립트 타이머가 어떻게 동작하는지 이해하는것은 중요하다. 가끔 타이머들은 직관적으로 작동하지 않는데, 그 이유는 타이머들이 속해있는 단일 스레드 때문이다. 타이머를 조절하고 만들기 위해 사용하는 세 개의 함수들을 살펴보는 것으로 시작해보자.

- `var id = setTimeout(fn, delay);` - 특정한 함수(fn)를 지연시간(delay) 이후에 호출하는 단일 타이머를 발생시킨다. 함수는 나중에 타이머를 취소할 수 있도록 고유의 ID를 리턴한다.
- `var id = setInterval(fn, delay);` - `setTimeout`과 유사하지만, 취소하기 전까지 지연시간(delay)후에 함수를 부르는 과정을 반복한다.
- `clearInterval(id);, clearTimeout(id);` - 타이머의 ID(앞에서 언급된 두 함수들로 부터 리턴된 값들)를 받아들여서 타이머가 콜백을 부르는 것을 멈추게 한다.

내부적으로 타이머가 어떻게 작동하는지 이해하기 위해서는 **타이머의 지연시간은 보장되지 않는다**는 하나의 중요한 컨셉을 살펴볼 필요가 있다. 브라우저의 모든 자바스크립트는 단일 스레드에서 실행되므로, 비동기식 이벤트(마우스 클릭과 타이머와 같은 이벤트들)은 실행이 시작될때만 작동하게 된다. 다음의 다이어그램과 같이 나타낼 수 있다.

![diagream](https://johnresig.com/files/Timers.png)

위 그림에는 소화해내기 많은 정보들이 있지만, 이것을 완전히 이해하는것은 어떻게 비동기적 자바스크립트 실행이 작동하는지에 대해 더 나은 깨달음을 줄 것이다. 이 다이어그램은 수직적으로 시간이 밀리초 단위로 표시되고 있는 1차원적 다이어그램이다. 파란색 박스들은 자바스크립트가 실행되고 있는 부분을 표현하고 있다. 예를 들어, 자바스크립트의 첫 블록은 약 18밀리초 동안 실행되었고, 마우스 클릭은 약 11초동안 실행되었다.

자바스크립트는 같은 시간동안에는 한 부분의 코드만을 실행할 수 있기 때문에(단일 스레드의 특성 때문이다) 이 블록들의 코드들은 다른 비동기 이벤트가 진행되는것을 "막고있다(blocking)". 이것은 비동기 이벤트가 일어나면(마우스 클릭이나, 타이머 실행, 혹은 XMLHttpRequest의 완료 와 같은) 큐에 들어갔다가, 나중에 실행된다는 것을 의미한다.(어떻게 이벤트가 큐잉되는지는 브라우저마다 다르므로, 단순화하여 다루기로 하자)

10ms의 setTimeout과 10ms의 setInterval 두 개의 타이머가 발생된 첫 번째 자바스크립트의 블록으로 시작하자. 타이머가 시작되었단 시작된 장소와 시간 대문에, 실제로는 코드의 첫번째 블록이 완료되기 전에 발생했다. 하지만, 그것이 즉시 실행되지는 않았음에 주목하자(쓰레딩 때문에 그런 일을 하지는 못한다). 대신 지연된 함수가 다음 가능한 순간에 실행될 수 있도록 큐안에 들어갔다.

추가적으로, 첫번째 자바스크립트 블록안에서 우리는 마우스 클릭이 발생한 것을 볼 수 있다. 이런 비동기 이벤트들(우리는 언제 유저가 행동을 취할지 절대로 알 수 없으므로 비동기적으로 여겨진다)과 연관되어 있는 자바스크립트 콜백들은 바로 실행될 수 없으므로, 초기의 타이머와 같이 큐에 들어가있다가 나중에 실행된다.

자바스크립트의 초기 블록이 실행을 끝마친 후에, 브라우저는 즉시 질문을 던진다: 다음에 실행되길 기다리고있는게 누구지? 이 경우에는, 마우스 클릭 핸들러와 타이머 콜백이 기다리고 있다. 브라우저는 하나를 고르고는(마우스 클릭 콜백) 즉시 실행한다. 타이머는 실행되기 위해서 다음 가능한 시간까지 기다려야 할 것이다.

마우스 클릭 핸들러가 실행되는 동안에 첫 번째 인터벌 콜백이 실행된것에 주목하자. 타이머의와 마찬가지로 그 핸들러가 나중의 실행을 위해 큐에 들어가 있다. 하지만 이번에 인터벌이 다시 발생되었을 때(타이머 핸들러가 실행중), 핸들러 실행은 드랍된 것에 주의하자. 만약 거대한 코드의 블럭이 실행되고 있을 때, 모든 인터벌 콜백들을 기다리고 있다면, 그 결과는 완료된 시점부터 인터벌 뭉치들이 간격없이 실행되버리는것이 되고 말 것이다. 그 대신, 브라우저는 단순하게 더 큐를 늘리기 전에 더 이상의 큐안에있는(인터벌에서의 질문을 위해서) 인터벌 헨들러들이 없을때 까지 기다리려는 경향이 있다.

사실 우리는 이 경우에서 세번째 인터벌 콜백이 인터벌 그 자신이 실행되는 동안 발생한 것을 볼 수 있다. 이것은 우리에게 중요한 사실을 보여준다: 인터벌들은 현재 무엇이 실행중인지 신경쓰지 않는다. 콜백들 사이의 시간이 희생된다고 하더라도 마구잡이로 큐에 들어갈 것이다.

마지막으로 두 번째 인터벌 콜백의 실행이 종료된 이휑, 우리는 자바스크립트 엔진 내에 실행할 것이 아무것도 없다는 것을 볼 수 있다. 이것은 브라우저가 이제 새로운 비동기 이벤트가 일어나기를 기다리고 있다는 것을 의미한다. 우리는 이것을 인터벌이 다시 발생되는 50ms마크에서 확인할 수 있다. 하지만 이번에는 아무것도 실행을 막고(blocking)있지 않으므로 즉시 실행된다.

`setTimeout`과 `setInterval`의 차이점을 더 잘 설명할 수 있는 예제를 살펴보자.

```js
setTimeout(function(){
    /* 긴 코드가 여기에 있다고 가정 ... */
    setTimeout(arguments.callee, 10);
}, 10);

setInterval(function(){
    /* 긴 코드가 여기에 있다고 가정 ... */
}, 10);
```

이 두 조각의 코드들은 첫눈에 보기에는 기능적으로 동일해보일지 모르지만, 실은 그렇지 않다. 특히 `setTimeout`코드는 항상 최소한 10ms의 지연시간을 이전의 콜백 실행으로부터 갖게된다. 반대로 `setInterval`은 마지막 콜백이 언제 실행되었는지에 관계없이 10ms마다 콜백을 실행하려고 할 것이다.

우리는 여기서 배운것이 매우 많다. 정리해보자:

- 자바스크립트 엔진은 비동기적 이벤트를 큐에 넣어 실행을 기다리는 오직 하나의 단일 스레드를 갖는다.
- `setTimeout`과 `setInterval`은 기본적으로 비동기적 코드를 실행하는 방법이 다르다.
- 타이머가 즉시 실행이 막혔을때는 다음 실행이 가능한 부분까지 지연될 것이다.(지연되는 시간은 원래 요구했던 지연시간보다 길어질 수 있다)
- 인터벌들은 실행되는데 긴 시간이 걸린다면(지정한 지연시간보다 오래 걸리면) 지연없이 연속적으로 실행될 것이다.

자바스크립트 엔진이 어떻게 작동하는지에 대한 이 모든것들은 매우 중요한 지식이다. 특히 일반적으로 발생하는 거대한 숫자의 비동기 이벤트들이 많은 경우, 고급 어플리케이션 코드를 작성하기위한 훌륭한 발판이 될 것이다.
